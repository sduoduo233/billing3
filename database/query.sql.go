// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package database

import (
	"context"

	"billing3/database/types"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const addInvoicePayment = `-- name: AddInvoicePayment :one
INSERT INTO invoice_payments (invoice_id, description, amount, reference_id, gateway) VALUES ($1, $2, $3, $4, $5) RETURNING id
`

type AddInvoicePaymentParams struct {
	InvoiceID   int32           `json:"invoice_id"`
	Description string          `json:"description"`
	Amount      decimal.Decimal `json:"amount"`
	ReferenceID string          `json:"reference_id"`
	Gateway     string          `json:"gateway"`
}

func (q *Queries) AddInvoicePayment(ctx context.Context, arg AddInvoicePaymentParams) (int32, error) {
	row := q.db.QueryRow(ctx, addInvoicePayment,
		arg.InvoiceID,
		arg.Description,
		arg.Amount,
		arg.ReferenceID,
		arg.Gateway,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const countServicesByServer = `-- name: CountServicesByServer :one
SELECT COUNT(id) FROM services WHERE (status = 'PENDING' OR status = 'ACTIVE' OR status = 'SUSPENDED' OR status = 'UNPAID') AND (settings::jsonb ? 'server' AND (settings->>'server')::integer = $1::integer)
`

func (q *Queries) CountServicesByServer(ctx context.Context, server int32) (int64, error) {
	row := q.db.QueryRow(ctx, countServicesByServer, server)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countServicesPaged = `-- name: CountServicesPaged :one
SELECT COUNT(id) FROM services WHERE ($1::text = '' OR $1::text = label) AND ($2::integer = 0 OR (settings::jsonb ? 'server' AND (settings->>'server')::integer = $2::integer)) AND ($3::integer = 0 OR $3::integer = user_id) AND ($4::text = '' OR $4::text = status)
`

type CountServicesPagedParams struct {
	Label  string `json:"label"`
	Server int32  `json:"server"`
	UserID int32  `json:"user_id"`
	Status string `json:"status"`
}

func (q *Queries) CountServicesPaged(ctx context.Context, arg CountServicesPagedParams) (int64, error) {
	row := q.db.QueryRow(ctx, countServicesPaged,
		arg.Label,
		arg.Server,
		arg.UserID,
		arg.Status,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUnpaidInvoiceForService = `-- name: CountUnpaidInvoiceForService :one

SELECT COUNT(*) FROM invoices INNER JOIN invoice_items ON invoices.id = invoice_items.invoice_id WHERE invoice_items.item_id = $1 AND invoice_items.type = 'service' AND invoices.status = 'UNPAID'
`

// INVOICES --
func (q *Queries) CountUnpaidInvoiceForService(ctx context.Context, itemID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countUnpaidInvoiceForService, itemID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (name, description) VALUES ($1, $2) RETURNING id
`

type CreateCategoryParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (int32, error) {
	row := q.db.QueryRow(ctx, createCategory, arg.Name, arg.Description)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createGatewayOrIgnore = `-- name: CreateGatewayOrIgnore :exec
INSERT INTO gateways (name, display_name, settings, enabled, fee) VALUES ($1, $1, '{}'::json, false, '0.00%') ON CONFLICT DO NOTHING
`

func (q *Queries) CreateGatewayOrIgnore(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, createGatewayOrIgnore, name)
	return err
}

const createInvoice = `-- name: CreateInvoice :one
INSERT INTO invoices (user_id, status, cancellation_reason, paid_at, due_at, amount) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id
`

type CreateInvoiceParams struct {
	UserID             int32           `json:"user_id"`
	Status             string          `json:"status"`
	CancellationReason pgtype.Text     `json:"cancellation_reason"`
	PaidAt             types.Timestamp `json:"paid_at"`
	DueAt              types.Timestamp `json:"due_at"`
	Amount             decimal.Decimal `json:"amount"`
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (int32, error) {
	row := q.db.QueryRow(ctx, createInvoice,
		arg.UserID,
		arg.Status,
		arg.CancellationReason,
		arg.PaidAt,
		arg.DueAt,
		arg.Amount,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createInvoiceItem = `-- name: CreateInvoiceItem :exec
INSERT INTO invoice_items (invoice_id, description, amount, type, item_id) VALUES ($1, $2, $3, $4, $5)
`

type CreateInvoiceItemParams struct {
	InvoiceID   int32           `json:"invoice_id"`
	Description string          `json:"description"`
	Amount      decimal.Decimal `json:"amount"`
	Type        string          `json:"type"`
	ItemID      pgtype.Int4     `json:"item_id"`
}

func (q *Queries) CreateInvoiceItem(ctx context.Context, arg CreateInvoiceItemParams) error {
	_, err := q.db.Exec(ctx, createInvoiceItem,
		arg.InvoiceID,
		arg.Description,
		arg.Amount,
		arg.Type,
		arg.ItemID,
	)
	return err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (name, description, category_id, extension, enabled, pricing, settings, stock, stock_control) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id
`

type CreateProductParams struct {
	Name         string                `json:"name"`
	Description  string                `json:"description"`
	CategoryID   int32                 `json:"category_id"`
	Extension    string                `json:"extension"`
	Enabled      bool                  `json:"enabled"`
	Pricing      types.ProductPrices   `json:"pricing"`
	Settings     types.ProductSettings `json:"settings"`
	Stock        int32                 `json:"stock"`
	StockControl int32                 `json:"stock_control"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (int32, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Name,
		arg.Description,
		arg.CategoryID,
		arg.Extension,
		arg.Enabled,
		arg.Pricing,
		arg.Settings,
		arg.Stock,
		arg.StockControl,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createProductOption = `-- name: CreateProductOption :exec
INSERT INTO product_options (product_id, name, display_name, type, regex, values, description) VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateProductOptionParams struct {
	ProductID   int32                     `json:"product_id"`
	Name        string                    `json:"name"`
	DisplayName string                    `json:"display_name"`
	Type        string                    `json:"type"`
	Regex       string                    `json:"regex"`
	Values      types.ProductOptionValues `json:"values"`
	Description string                    `json:"description"`
}

func (q *Queries) CreateProductOption(ctx context.Context, arg CreateProductOptionParams) error {
	_, err := q.db.Exec(ctx, createProductOption,
		arg.ProductID,
		arg.Name,
		arg.DisplayName,
		arg.Type,
		arg.Regex,
		arg.Values,
		arg.Description,
	)
	return err
}

const createServer = `-- name: CreateServer :one
INSERT INTO servers (label, extension, settings) VALUES ($1, $2, $3) RETURNING id
`

type CreateServerParams struct {
	Label     string               `json:"label"`
	Extension string               `json:"extension"`
	Settings  types.ServerSettings `json:"settings"`
}

func (q *Queries) CreateServer(ctx context.Context, arg CreateServerParams) (int32, error) {
	row := q.db.QueryRow(ctx, createServer, arg.Label, arg.Extension, arg.Settings)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createService = `-- name: CreateService :one
INSERT INTO services (label, user_id, status, billing_cycle, price, extension, settings, expires_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id
`

type CreateServiceParams struct {
	Label        string                `json:"label"`
	UserID       int32                 `json:"user_id"`
	Status       string                `json:"status"`
	BillingCycle int32                 `json:"billing_cycle"`
	Price        decimal.Decimal       `json:"price"`
	Extension    string                `json:"extension"`
	Settings     types.ServiceSettings `json:"settings"`
	ExpiresAt    types.Timestamp       `json:"expires_at"`
}

func (q *Queries) CreateService(ctx context.Context, arg CreateServiceParams) (int32, error) {
	row := q.db.QueryRow(ctx, createService,
		arg.Label,
		arg.UserID,
		arg.Status,
		arg.BillingCycle,
		arg.Price,
		arg.Extension,
		arg.Settings,
		arg.ExpiresAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createSession = `-- name: CreateSession :exec
INSERT INTO sessions (token, user_id, expires_at) VALUES ($1, $2, $3)
`

type CreateSessionParams struct {
	Token     string          `json:"token"`
	UserID    int32           `json:"user_id"`
	ExpiresAt types.Timestamp `json:"expires_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) error {
	_, err := q.db.Exec(ctx, createSession, arg.Token, arg.UserID, arg.ExpiresAt)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, name, role, password, address, city, state, country, zip_code) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id
`

type CreateUserParams struct {
	Email    string      `json:"email"`
	Name     string      `json:"name"`
	Role     string      `json:"role"`
	Password string      `json:"-"`
	Address  pgtype.Text `json:"address"`
	City     pgtype.Text `json:"city"`
	State    pgtype.Text `json:"state"`
	Country  pgtype.Text `json:"country"`
	ZipCode  pgtype.Text `json:"zip_code"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int32, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.Name,
		arg.Role,
		arg.Password,
		arg.Address,
		arg.City,
		arg.State,
		arg.Country,
		arg.ZipCode,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteAllInvoiceItems = `-- name: DeleteAllInvoiceItems :exec
DELETE FROM invoice_items WHERE invoice_id = $1
`

func (q *Queries) DeleteAllInvoiceItems(ctx context.Context, invoiceID int32) error {
	_, err := q.db.Exec(ctx, deleteAllInvoiceItems, invoiceID)
	return err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCategory, id)
	return err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM sessions WHERE expires_at < CURRENT_TIMESTAMP
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredSessions)
	return err
}

const deleteGatewayByName = `-- name: DeleteGatewayByName :exec
DELETE FROM gateways WHERE name = $1
`

func (q *Queries) DeleteGatewayByName(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deleteGatewayByName, name)
	return err
}

const deleteInvoiceItem = `-- name: DeleteInvoiceItem :exec
DELETE FROM invoice_items WHERE id = $1 AND invoice_id = $2
`

type DeleteInvoiceItemParams struct {
	ID        int32 `json:"id"`
	InvoiceID int32 `json:"invoice_id"`
}

func (q *Queries) DeleteInvoiceItem(ctx context.Context, arg DeleteInvoiceItemParams) error {
	_, err := q.db.Exec(ctx, deleteInvoiceItem, arg.ID, arg.InvoiceID)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const deleteProductOptionsByProduct = `-- name: DeleteProductOptionsByProduct :exec
DELETE FROM product_options WHERE product_id = $1
`

func (q *Queries) DeleteProductOptionsByProduct(ctx context.Context, productID int32) error {
	_, err := q.db.Exec(ctx, deleteProductOptionsByProduct, productID)
	return err
}

const deleteServer = `-- name: DeleteServer :exec
DELETE FROM servers WHERE id = $1
`

func (q *Queries) DeleteServer(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteServer, id)
	return err
}

const deleteService = `-- name: DeleteService :exec
DELETE FROM services WHERE id = $1
`

func (q *Queries) DeleteService(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteService, id)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE token = $1
`

func (q *Queries) DeleteSession(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, deleteSession, token)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const findCategoryById = `-- name: FindCategoryById :one

SELECT id, name, description FROM categories WHERE id = $1
`

// CATEGORIES --
func (q *Queries) FindCategoryById(ctx context.Context, id int32) (Category, error) {
	row := q.db.QueryRow(ctx, findCategoryById, id)
	var i Category
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const findEnabledProductsByCategory = `-- name: FindEnabledProductsByCategory :many

SELECT id, name, description, category_id, extension, enabled, pricing, settings, stock, stock_control FROM products WHERE category_id = $1 AND enabled = TRUE
`

// PRODUCTS --
func (q *Queries) FindEnabledProductsByCategory(ctx context.Context, categoryID int32) ([]Product, error) {
	rows, err := q.db.Query(ctx, findEnabledProductsByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.Extension,
			&i.Enabled,
			&i.Pricing,
			&i.Settings,
			&i.Stock,
			&i.StockControl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findGatewayById = `-- name: FindGatewayById :one
SELECT id, display_name, name, settings, enabled, fee FROM gateways WHERE id = $1
`

func (q *Queries) FindGatewayById(ctx context.Context, id int32) (Gateway, error) {
	row := q.db.QueryRow(ctx, findGatewayById, id)
	var i Gateway
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Name,
		&i.Settings,
		&i.Enabled,
		&i.Fee,
	)
	return i, err
}

const findGatewayByName = `-- name: FindGatewayByName :one
SELECT id, display_name, name, settings, enabled, fee FROM gateways WHERE name = $1
`

func (q *Queries) FindGatewayByName(ctx context.Context, name string) (Gateway, error) {
	row := q.db.QueryRow(ctx, findGatewayByName, name)
	var i Gateway
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Name,
		&i.Settings,
		&i.Enabled,
		&i.Fee,
	)
	return i, err
}

const findInvoiceById = `-- name: FindInvoiceById :one
SELECT id, user_id, status, cancellation_reason, paid_at, due_at, amount, created_at FROM invoices WHERE id = $1
`

func (q *Queries) FindInvoiceById(ctx context.Context, id int32) (Invoice, error) {
	row := q.db.QueryRow(ctx, findInvoiceById, id)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.CancellationReason,
		&i.PaidAt,
		&i.DueAt,
		&i.Amount,
		&i.CreatedAt,
	)
	return i, err
}

const findInvoiceByIdWithUsername = `-- name: FindInvoiceByIdWithUsername :one
SELECT invoices.id, invoices.user_id, invoices.status, invoices.cancellation_reason, invoices.paid_at, invoices.due_at, invoices.amount, invoices.created_at, users.name AS username FROM invoices INNER JOIN users ON invoices.user_id = users.id WHERE invoices.id = $1
`

type FindInvoiceByIdWithUsernameRow struct {
	ID                 int32           `json:"id"`
	UserID             int32           `json:"user_id"`
	Status             string          `json:"status"`
	CancellationReason pgtype.Text     `json:"cancellation_reason"`
	PaidAt             types.Timestamp `json:"paid_at"`
	DueAt              types.Timestamp `json:"due_at"`
	Amount             decimal.Decimal `json:"amount"`
	CreatedAt          types.Timestamp `json:"created_at"`
	Username           string          `json:"username"`
}

func (q *Queries) FindInvoiceByIdWithUsername(ctx context.Context, id int32) (FindInvoiceByIdWithUsernameRow, error) {
	row := q.db.QueryRow(ctx, findInvoiceByIdWithUsername, id)
	var i FindInvoiceByIdWithUsernameRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.CancellationReason,
		&i.PaidAt,
		&i.DueAt,
		&i.Amount,
		&i.CreatedAt,
		&i.Username,
	)
	return i, err
}

const findInvoiceByService = `-- name: FindInvoiceByService :many
SELECT invoices.id, invoices.user_id, invoices.status, invoices.cancellation_reason, invoices.paid_at, invoices.due_at, invoices.amount, invoices.created_at FROM invoices INNER JOIN invoice_items ON invoices.id = invoice_items.invoice_id WHERE invoice_items.item_id = $1 AND invoice_items.type = 'service' ORDER BY invoices.id DESC
`

func (q *Queries) FindInvoiceByService(ctx context.Context, itemID pgtype.Int4) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, findInvoiceByService, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.CancellationReason,
			&i.PaidAt,
			&i.DueAt,
			&i.Amount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findProductById = `-- name: FindProductById :one
SELECT id, name, description, category_id, extension, enabled, pricing, settings, stock, stock_control FROM products WHERE id = $1
`

func (q *Queries) FindProductById(ctx context.Context, id int32) (Product, error) {
	row := q.db.QueryRow(ctx, findProductById, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CategoryID,
		&i.Extension,
		&i.Enabled,
		&i.Pricing,
		&i.Settings,
		&i.Stock,
		&i.StockControl,
	)
	return i, err
}

const findProductOptionsByProduct = `-- name: FindProductOptionsByProduct :many
SELECT product_id, name, display_name, type, regex, values, description FROM product_options WHERE product_id = $1
`

func (q *Queries) FindProductOptionsByProduct(ctx context.Context, productID int32) ([]ProductOption, error) {
	rows, err := q.db.Query(ctx, findProductOptionsByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductOption{}
	for rows.Next() {
		var i ProductOption
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.DisplayName,
			&i.Type,
			&i.Regex,
			&i.Values,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findProductsByCategory = `-- name: FindProductsByCategory :many
SELECT id, name, description, category_id, extension, enabled, pricing, settings, stock, stock_control FROM products WHERE category_id = $1 ORDER BY id
`

func (q *Queries) FindProductsByCategory(ctx context.Context, categoryID int32) ([]Product, error) {
	rows, err := q.db.Query(ctx, findProductsByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.Extension,
			&i.Enabled,
			&i.Pricing,
			&i.Settings,
			&i.Stock,
			&i.StockControl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findServerById = `-- name: FindServerById :one
SELECT id, label, extension, settings FROM servers WHERE id = $1
`

func (q *Queries) FindServerById(ctx context.Context, id int32) (Server, error) {
	row := q.db.QueryRow(ctx, findServerById, id)
	var i Server
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.Extension,
		&i.Settings,
	)
	return i, err
}

const findServiceById = `-- name: FindServiceById :one
SELECT id, label, user_id, status, cancellation_reason, billing_cycle, price, extension, settings, expires_at, created_at, cancelled_at FROM services WHERE id = $1
`

func (q *Queries) FindServiceById(ctx context.Context, id int32) (Service, error) {
	row := q.db.QueryRow(ctx, findServiceById, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.UserID,
		&i.Status,
		&i.CancellationReason,
		&i.BillingCycle,
		&i.Price,
		&i.Extension,
		&i.Settings,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.CancelledAt,
	)
	return i, err
}

const findServiceByIdForUpdate = `-- name: FindServiceByIdForUpdate :one

SELECT id, label, user_id, status, cancellation_reason, billing_cycle, price, extension, settings, expires_at, created_at, cancelled_at FROM services WHERE id = $1 FOR UPDATE
`

// SERVICES --
func (q *Queries) FindServiceByIdForUpdate(ctx context.Context, id int32) (Service, error) {
	row := q.db.QueryRow(ctx, findServiceByIdForUpdate, id)
	var i Service
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.UserID,
		&i.Status,
		&i.CancellationReason,
		&i.BillingCycle,
		&i.Price,
		&i.Extension,
		&i.Settings,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.CancelledAt,
	)
	return i, err
}

const findServiceByIdWithName = `-- name: FindServiceByIdWithName :one
SELECT services.id, services.label, services.user_id, services.status, services.cancellation_reason, services.billing_cycle, services.price, services.extension, services.settings, services.expires_at, services.created_at, services.cancelled_at, users.name FROM services INNER JOIN users ON services.user_id = users.id WHERE services.id = $1
`

type FindServiceByIdWithNameRow struct {
	ID                 int32                 `json:"id"`
	Label              string                `json:"label"`
	UserID             int32                 `json:"user_id"`
	Status             string                `json:"status"`
	CancellationReason pgtype.Text           `json:"cancellation_reason"`
	BillingCycle       int32                 `json:"billing_cycle"`
	Price              decimal.Decimal       `json:"price"`
	Extension          string                `json:"extension"`
	Settings           types.ServiceSettings `json:"settings"`
	ExpiresAt          types.Timestamp       `json:"expires_at"`
	CreatedAt          types.Timestamp       `json:"created_at"`
	CancelledAt        types.Timestamp       `json:"cancelled_at"`
	Name               string                `json:"name"`
}

func (q *Queries) FindServiceByIdWithName(ctx context.Context, id int32) (FindServiceByIdWithNameRow, error) {
	row := q.db.QueryRow(ctx, findServiceByIdWithName, id)
	var i FindServiceByIdWithNameRow
	err := row.Scan(
		&i.ID,
		&i.Label,
		&i.UserID,
		&i.Status,
		&i.CancellationReason,
		&i.BillingCycle,
		&i.Price,
		&i.Extension,
		&i.Settings,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.CancelledAt,
		&i.Name,
	)
	return i, err
}

const findSessionByToken = `-- name: FindSessionByToken :one

SELECT id, token, user_id, created_at, expires_at FROM sessions WHERE token = $1 AND expires_at > CURRENT_TIMESTAMP
`

// SESSIONS --
func (q *Queries) FindSessionByToken(ctx context.Context, token string) (Session, error) {
	row := q.db.QueryRow(ctx, findSessionByToken, token)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT id, email, name, role, password, address, city, state, country, zip_code FROM users WHERE email = $1
`

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Role,
		&i.Password,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.ZipCode,
	)
	return i, err
}

const findUserById = `-- name: FindUserById :one
SELECT id, email, name, role, password, address, city, state, country, zip_code FROM users WHERE id = $1
`

func (q *Queries) FindUserById(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, findUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Role,
		&i.Password,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.ZipCode,
	)
	return i, err
}

const listCategories = `-- name: ListCategories :many
SELECT id, name, description FROM categories ORDER BY id
`

func (q *Queries) ListCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.Query(ctx, listCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Category{}
	for rows.Next() {
		var i Category
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnabledGateways = `-- name: ListEnabledGateways :many
SELECT display_name, name FROM gateways WHERE enabled = true ORDER BY id ASC
`

type ListEnabledGatewaysRow struct {
	DisplayName string `json:"display_name"`
	Name        string `json:"name"`
}

func (q *Queries) ListEnabledGateways(ctx context.Context) ([]ListEnabledGatewaysRow, error) {
	rows, err := q.db.Query(ctx, listEnabledGateways)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEnabledGatewaysRow{}
	for rows.Next() {
		var i ListEnabledGatewaysRow
		if err := rows.Scan(&i.DisplayName, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnabledProducts = `-- name: ListEnabledProducts :many
SELECT id, name, description, category_id, extension, enabled, pricing, settings, stock, stock_control FROM products WHERE enabled ORDER BY id
`

func (q *Queries) ListEnabledProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.Query(ctx, listEnabledProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.Extension,
			&i.Enabled,
			&i.Pricing,
			&i.Settings,
			&i.Stock,
			&i.StockControl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGatewayNames = `-- name: ListGatewayNames :many
SELECT name FROM gateways ORDER BY id ASC
`

func (q *Queries) ListGatewayNames(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, listGatewayNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGateways = `-- name: ListGateways :many

SELECT id, display_name, name, settings, enabled, fee FROM gateways ORDER BY id ASC
`

// GATEWAYS --
func (q *Queries) ListGateways(ctx context.Context) ([]Gateway, error) {
	rows, err := q.db.Query(ctx, listGateways)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Gateway{}
	for rows.Next() {
		var i Gateway
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.Name,
			&i.Settings,
			&i.Enabled,
			&i.Fee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoiceItems = `-- name: ListInvoiceItems :many
SELECT id, invoice_id, description, amount, type, item_id, created_at FROM invoice_items WHERE invoice_id = $1 ORDER BY id
`

func (q *Queries) ListInvoiceItems(ctx context.Context, invoiceID int32) ([]InvoiceItem, error) {
	rows, err := q.db.Query(ctx, listInvoiceItems, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InvoiceItem{}
	for rows.Next() {
		var i InvoiceItem
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceID,
			&i.Description,
			&i.Amount,
			&i.Type,
			&i.ItemID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicePayments = `-- name: ListInvoicePayments :many
SELECT id, invoice_id, created_at, description, amount, reference_id, gateway FROM invoice_payments WHERE invoice_id = $1 ORDER BY id ASC
`

func (q *Queries) ListInvoicePayments(ctx context.Context, invoiceID int32) ([]InvoicePayment, error) {
	rows, err := q.db.Query(ctx, listInvoicePayments, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InvoicePayment{}
	for rows.Next() {
		var i InvoicePayment
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceID,
			&i.CreatedAt,
			&i.Description,
			&i.Amount,
			&i.ReferenceID,
			&i.Gateway,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT id, name, description, category_id, extension, enabled, pricing, settings, stock, stock_control FROM products ORDER BY id
`

func (q *Queries) ListProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.Extension,
			&i.Enabled,
			&i.Pricing,
			&i.Settings,
			&i.Stock,
			&i.StockControl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listServers = `-- name: ListServers :many

SELECT id, label, extension, settings FROM servers ORDER BY id ASC
`

// SERVERS --
func (q *Queries) ListServers(ctx context.Context) ([]Server, error) {
	rows, err := q.db.Query(ctx, listServers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Server{}
	for rows.Next() {
		var i Server
		if err := rows.Scan(
			&i.ID,
			&i.Label,
			&i.Extension,
			&i.Settings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many

SELECT id, email, name, role, password, address, city, state, country, zip_code FROM users ORDER BY id
`

// USERS --
func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Role,
			&i.Password,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.ZipCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchInvoicesCount = `-- name: SearchInvoicesCount :one
SELECT COUNT(*) FROM invoices WHERE ($1::text = '' OR $1::text = status) AND ($2::integer = 0 OR $2::integer = user_id)
`

type SearchInvoicesCountParams struct {
	Status string `json:"status"`
	UserID int32  `json:"user_id"`
}

func (q *Queries) SearchInvoicesCount(ctx context.Context, arg SearchInvoicesCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, searchInvoicesCount, arg.Status, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const searchInvoicesPaged = `-- name: SearchInvoicesPaged :many
SELECT id, user_id, status, cancellation_reason, paid_at, due_at, amount, created_at FROM invoices WHERE ($3::text = '' OR $3::text = status) AND ($4::integer = 0 OR $4::integer = user_id) ORDER BY id DESC LIMIT $1 OFFSET $2
`

type SearchInvoicesPagedParams struct {
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Status string `json:"status"`
	UserID int32  `json:"user_id"`
}

func (q *Queries) SearchInvoicesPaged(ctx context.Context, arg SearchInvoicesPagedParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, searchInvoicesPaged,
		arg.Limit,
		arg.Offset,
		arg.Status,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.CancellationReason,
			&i.PaidAt,
			&i.DueAt,
			&i.Amount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProduct = `-- name: SearchProduct :many
SELECT products.id as id, products.name, products.description, products.category_id, products.extension, products.enabled, products.pricing, products.settings, products.stock, products.stock_control, categories.name AS category_name FROM products INNER JOIN categories ON categories.id = products.category_id  WHERE (category_id = $1 OR $1 < 1) ORDER BY products.id
`

type SearchProductRow struct {
	ID           int32                 `json:"id"`
	Name         string                `json:"name"`
	Description  string                `json:"description"`
	CategoryID   int32                 `json:"category_id"`
	Extension    string                `json:"extension"`
	Enabled      bool                  `json:"enabled"`
	Pricing      types.ProductPrices   `json:"pricing"`
	Settings     types.ProductSettings `json:"settings"`
	Stock        int32                 `json:"stock"`
	StockControl int32                 `json:"stock_control"`
	CategoryName string                `json:"category_name"`
}

func (q *Queries) SearchProduct(ctx context.Context, categoryID int32) ([]SearchProductRow, error) {
	rows, err := q.db.Query(ctx, searchProduct, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchProductRow{}
	for rows.Next() {
		var i SearchProductRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CategoryID,
			&i.Extension,
			&i.Enabled,
			&i.Pricing,
			&i.Settings,
			&i.Stock,
			&i.StockControl,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchServicesPaged = `-- name: SearchServicesPaged :many
SELECT services.label, users.name, services.id, services.status, services.user_id, services.price, services.created_at, services.billing_cycle, services.expires_at FROM services INNER JOIN users ON services.user_id = users.id WHERE ($3::text = '' OR $3::text = label) AND ($4::integer = 0 OR (settings ? 'server' AND (settings->>'server')::integer = $4::integer)) AND ($5::integer = 0 OR $5::integer = user_id) AND ($6::text = '' OR $6::text = status) ORDER BY services.id DESC LIMIT $1 OFFSET $2
`

type SearchServicesPagedParams struct {
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Label  string `json:"label"`
	Server int32  `json:"server"`
	UserID int32  `json:"user_id"`
	Status string `json:"status"`
}

type SearchServicesPagedRow struct {
	Label        string          `json:"label"`
	Name         string          `json:"name"`
	ID           int32           `json:"id"`
	Status       string          `json:"status"`
	UserID       int32           `json:"user_id"`
	Price        decimal.Decimal `json:"price"`
	CreatedAt    types.Timestamp `json:"created_at"`
	BillingCycle int32           `json:"billing_cycle"`
	ExpiresAt    types.Timestamp `json:"expires_at"`
}

func (q *Queries) SearchServicesPaged(ctx context.Context, arg SearchServicesPagedParams) ([]SearchServicesPagedRow, error) {
	rows, err := q.db.Query(ctx, searchServicesPaged,
		arg.Limit,
		arg.Offset,
		arg.Label,
		arg.Server,
		arg.UserID,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchServicesPagedRow{}
	for rows.Next() {
		var i SearchServicesPagedRow
		if err := rows.Scan(
			&i.Label,
			&i.Name,
			&i.ID,
			&i.Status,
			&i.UserID,
			&i.Price,
			&i.CreatedAt,
			&i.BillingCycle,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsersCount = `-- name: SearchUsersCount :one
SELECT count(*) FROM users WHERE position($1::text in email)>0 OR position($1::text in name)>0
`

func (q *Queries) SearchUsersCount(ctx context.Context, search string) (int64, error) {
	row := q.db.QueryRow(ctx, searchUsersCount, search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const searchUsersPaged = `-- name: SearchUsersPaged :many
SELECT id, email, name, role, password, address, city, state, country, zip_code FROM users WHERE position($3::text in email)>0 OR position($3::text in name)>0 ORDER BY id LIMIT $1 OFFSET $2
`

type SearchUsersPagedParams struct {
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Search string `json:"search"`
}

func (q *Queries) SearchUsersPaged(ctx context.Context, arg SearchUsersPagedParams) ([]User, error) {
	rows, err := q.db.Query(ctx, searchUsersPaged, arg.Limit, arg.Offset, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Role,
			&i.Password,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.ZipCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectInvoiceForUpdate = `-- name: SelectInvoiceForUpdate :one
SELECT id, user_id, status, cancellation_reason, paid_at, due_at, amount, created_at FROM invoices WHERE id = $1 FOR UPDATE
`

func (q *Queries) SelectInvoiceForUpdate(ctx context.Context, id int32) (Invoice, error) {
	row := q.db.QueryRow(ctx, selectInvoiceForUpdate, id)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.CancellationReason,
		&i.PaidAt,
		&i.DueAt,
		&i.Amount,
		&i.CreatedAt,
	)
	return i, err
}

const totalInvoicePayment = `-- name: TotalInvoicePayment :one
SELECT SUM(amount::decimal)::decimal FROM invoice_payments WHERE invoice_id = $1
`

func (q *Queries) TotalInvoicePayment(ctx context.Context, invoiceID int32) (decimal.Decimal, error) {
	row := q.db.QueryRow(ctx, totalInvoicePayment, invoiceID)
	var column_1 decimal.Decimal
	err := row.Scan(&column_1)
	return column_1, err
}

const updateCategory = `-- name: UpdateCategory :exec
UPDATE categories SET name = $1, description = $2 WHERE id = $3
`

type UpdateCategoryParams struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	ID          int32  `json:"id"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) error {
	_, err := q.db.Exec(ctx, updateCategory, arg.Name, arg.Description, arg.ID)
	return err
}

const updateGateway = `-- name: UpdateGateway :exec
UPDATE gateways SET display_name = $1, settings = $2, enabled = $3, fee = $4 WHERE name = $5
`

type UpdateGatewayParams struct {
	DisplayName string                `json:"display_name"`
	Settings    types.GatewaySettings `json:"settings"`
	Enabled     bool                  `json:"enabled"`
	Fee         pgtype.Text           `json:"fee"`
	Name        string                `json:"name"`
}

func (q *Queries) UpdateGateway(ctx context.Context, arg UpdateGatewayParams) error {
	_, err := q.db.Exec(ctx, updateGateway,
		arg.DisplayName,
		arg.Settings,
		arg.Enabled,
		arg.Fee,
		arg.Name,
	)
	return err
}

const updateInvoice = `-- name: UpdateInvoice :exec
UPDATE invoices SET status = $1, cancellation_reason = $2, paid_at = $3, due_at = $4 WHERE id = $5
`

type UpdateInvoiceParams struct {
	Status             string          `json:"status"`
	CancellationReason pgtype.Text     `json:"cancellation_reason"`
	PaidAt             types.Timestamp `json:"paid_at"`
	DueAt              types.Timestamp `json:"due_at"`
	ID                 int32           `json:"id"`
}

func (q *Queries) UpdateInvoice(ctx context.Context, arg UpdateInvoiceParams) error {
	_, err := q.db.Exec(ctx, updateInvoice,
		arg.Status,
		arg.CancellationReason,
		arg.PaidAt,
		arg.DueAt,
		arg.ID,
	)
	return err
}

const updateInvoiceAmount = `-- name: UpdateInvoiceAmount :exec
UPDATE invoices SET amount = (SELECT SUM(amount) FROM invoice_items WHERE invoice_id = $1) WHERE id = $1
`

func (q *Queries) UpdateInvoiceAmount(ctx context.Context, invoiceID int32) error {
	_, err := q.db.Exec(ctx, updateInvoiceAmount, invoiceID)
	return err
}

const updateInvoiceItem = `-- name: UpdateInvoiceItem :exec
UPDATE invoice_items SET description = $1, amount = $2 WHERE id = $3 AND invoice_id = $4
`

type UpdateInvoiceItemParams struct {
	Description string          `json:"description"`
	Amount      decimal.Decimal `json:"amount"`
	ID          int32           `json:"id"`
	InvoiceID   int32           `json:"invoice_id"`
}

func (q *Queries) UpdateInvoiceItem(ctx context.Context, arg UpdateInvoiceItemParams) error {
	_, err := q.db.Exec(ctx, updateInvoiceItem,
		arg.Description,
		arg.Amount,
		arg.ID,
		arg.InvoiceID,
	)
	return err
}

const updateInvoicePaid = `-- name: UpdateInvoicePaid :exec
UPDATE invoices SET status = 'PAID', paid_at = CURRENT_TIMESTAMP WHERE id = $1
`

func (q *Queries) UpdateInvoicePaid(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, updateInvoicePaid, id)
	return err
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE products SET name = $1, description = $2, category_id = $3, extension = $4, enabled = $5, pricing = $6, settings = $7, stock = $8, stock_control = $9 WHERE id = $10
`

type UpdateProductParams struct {
	Name         string                `json:"name"`
	Description  string                `json:"description"`
	CategoryID   int32                 `json:"category_id"`
	Extension    string                `json:"extension"`
	Enabled      bool                  `json:"enabled"`
	Pricing      types.ProductPrices   `json:"pricing"`
	Settings     types.ProductSettings `json:"settings"`
	Stock        int32                 `json:"stock"`
	StockControl int32                 `json:"stock_control"`
	ID           int32                 `json:"id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.Exec(ctx, updateProduct,
		arg.Name,
		arg.Description,
		arg.CategoryID,
		arg.Extension,
		arg.Enabled,
		arg.Pricing,
		arg.Settings,
		arg.Stock,
		arg.StockControl,
		arg.ID,
	)
	return err
}

const updateServer = `-- name: UpdateServer :exec
UPDATE servers SET label = $1, settings = $2, extension = $3 WHERE id = $4
`

type UpdateServerParams struct {
	Label     string               `json:"label"`
	Settings  types.ServerSettings `json:"settings"`
	Extension string               `json:"extension"`
	ID        int32                `json:"id"`
}

func (q *Queries) UpdateServer(ctx context.Context, arg UpdateServerParams) error {
	_, err := q.db.Exec(ctx, updateServer,
		arg.Label,
		arg.Settings,
		arg.Extension,
		arg.ID,
	)
	return err
}

const updateService = `-- name: UpdateService :exec
UPDATE services SET label = $1, billing_cycle = $2, price = $3, expires_at = $4 WHERE id = $5
`

type UpdateServiceParams struct {
	Label        string          `json:"label"`
	BillingCycle int32           `json:"billing_cycle"`
	Price        decimal.Decimal `json:"price"`
	ExpiresAt    types.Timestamp `json:"expires_at"`
	ID           int32           `json:"id"`
}

func (q *Queries) UpdateService(ctx context.Context, arg UpdateServiceParams) error {
	_, err := q.db.Exec(ctx, updateService,
		arg.Label,
		arg.BillingCycle,
		arg.Price,
		arg.ExpiresAt,
		arg.ID,
	)
	return err
}

const updateServiceCancelled = `-- name: UpdateServiceCancelled :exec
UPDATE services SET cancellation_reason = $1, cancelled_at = $2 WHERE id = $3
`

type UpdateServiceCancelledParams struct {
	CancellationReason pgtype.Text     `json:"cancellation_reason"`
	CancelledAt        types.Timestamp `json:"cancelled_at"`
	ID                 int32           `json:"id"`
}

func (q *Queries) UpdateServiceCancelled(ctx context.Context, arg UpdateServiceCancelledParams) error {
	_, err := q.db.Exec(ctx, updateServiceCancelled, arg.CancellationReason, arg.CancelledAt, arg.ID)
	return err
}

const updateServiceExpiryTime = `-- name: UpdateServiceExpiryTime :exec
UPDATE services SET expires_at = $2 WHERE id = $1
`

type UpdateServiceExpiryTimeParams struct {
	ID        int32           `json:"id"`
	ExpiresAt types.Timestamp `json:"expires_at"`
}

func (q *Queries) UpdateServiceExpiryTime(ctx context.Context, arg UpdateServiceExpiryTimeParams) error {
	_, err := q.db.Exec(ctx, updateServiceExpiryTime, arg.ID, arg.ExpiresAt)
	return err
}

const updateServiceLabel = `-- name: UpdateServiceLabel :exec
UPDATE services SET label = $1 WHERE id = $2
`

type UpdateServiceLabelParams struct {
	Label string `json:"label"`
	ID    int32  `json:"id"`
}

func (q *Queries) UpdateServiceLabel(ctx context.Context, arg UpdateServiceLabelParams) error {
	_, err := q.db.Exec(ctx, updateServiceLabel, arg.Label, arg.ID)
	return err
}

const updateServiceSettings = `-- name: UpdateServiceSettings :exec
UPDATE services SET settings = $1 WHERE id = $2
`

type UpdateServiceSettingsParams struct {
	Settings types.ServiceSettings `json:"settings"`
	ID       int32                 `json:"id"`
}

func (q *Queries) UpdateServiceSettings(ctx context.Context, arg UpdateServiceSettingsParams) error {
	_, err := q.db.Exec(ctx, updateServiceSettings, arg.Settings, arg.ID)
	return err
}

const updateServiceStatus = `-- name: UpdateServiceStatus :exec
UPDATE services SET status = $1 WHERE id = $2
`

type UpdateServiceStatusParams struct {
	Status string `json:"status"`
	ID     int32  `json:"id"`
}

func (q *Queries) UpdateServiceStatus(ctx context.Context, arg UpdateServiceStatusParams) error {
	_, err := q.db.Exec(ctx, updateServiceStatus, arg.Status, arg.ID)
	return err
}

const updateSessionExpiryTime = `-- name: UpdateSessionExpiryTime :exec
UPDATE sessions SET expires_at = $2 WHERE token = $1
`

type UpdateSessionExpiryTimeParams struct {
	Token     string          `json:"token"`
	ExpiresAt types.Timestamp `json:"expires_at"`
}

func (q *Queries) UpdateSessionExpiryTime(ctx context.Context, arg UpdateSessionExpiryTimeParams) error {
	_, err := q.db.Exec(ctx, updateSessionExpiryTime, arg.Token, arg.ExpiresAt)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users SET email = $2, name = $3, role = $4, address = $5, city = $6, state = $7, country = $8, zip_code = $9 WHERE id = $1
`

type UpdateUserParams struct {
	ID      int32       `json:"id"`
	Email   string      `json:"email"`
	Name    string      `json:"name"`
	Role    string      `json:"role"`
	Address pgtype.Text `json:"address"`
	City    pgtype.Text `json:"city"`
	State   pgtype.Text `json:"state"`
	Country pgtype.Text `json:"country"`
	ZipCode pgtype.Text `json:"zip_code"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.ID,
		arg.Email,
		arg.Name,
		arg.Role,
		arg.Address,
		arg.City,
		arg.State,
		arg.Country,
		arg.ZipCode,
	)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users SET password = $2 WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID       int32  `json:"id"`
	Password string `json:"-"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.Password)
	return err
}
